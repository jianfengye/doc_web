# go语言的垃圾回收[未发布]

# 说说垃圾收集算法

说到垃圾回收，一般垃圾回收有好几个类型：引用计数方法，标记清扫方法，节点复制垃圾收集，分代垃圾收集方法。其中各个垃圾回收算法的都各有其优势和缺点。比如引用计数方法，需要维护额外的引用计数器，且最被诟病的是环形引用的问题。标记清扫算法的STW（Stop the World）的问题，它在垃圾收集的时候需要将现有服务暂停，然后才能进行垃圾回收，所以怎么将STW的时间降低或者均匀分配就是这个算法需要研究的。节点复制算法需要额外的空间，来将一个对象从FromSpace复制到TopSpace。而分代垃圾收集可能是现代用的最多的垃圾算法，基本思想是将空间分成年老代和年轻代，年轻代的空间存储新的对象，进行高频率的垃圾收集，而年老的空间进行低频率的垃圾收集。

而上面说的各种垃圾回收机制，又有很多算法的变种，甚至于几个算法共用的现象。

垃圾收集算法的好坏直接关系到整个系统的可用性，谁也不希望自己的系统占用过多的内存，或者出现卡顿（STW）情况。

# 说回Go语言

go的垃圾回收算法是使用标记清扫的垃圾回收算法。

标记清扫的算法分为两个阶段，标记阶段（Mark）和清扫阶段（Sweep），在标记阶段，垃圾回收器标记空间中的所有有用的对象，在清扫阶段，垃圾回收器遍历空间，回收所有没有被标记的对象。

go的标记阶段是使用了三色标记算法。每个对象有可能被标记为三个颜色

* 白色：表示不可到达的对象
* 灰色：表示还没被处理的对象
* 黑色：表示已经被标记的对象

标记过程：
1 所有对象最初都是白色的
2 从根出发，将所有初始可达到的对象，标记为灰色，并且推入栈
3 遍历所有灰色对象，将所有它引用到的白色对象标记为灰色，然后自身标记为黑色
4 重复步骤3，知道找不到灰色对象
5 剩下的对象不是白色就是黑色

这里的根代表栈，全局变量等。

回收过程：

遍历空间，把所有白色的对象进行回收。

# 代码

gc的触发时间点是个值得考虑的问题，在什么时候会触发gc。golang在分配内存的时候会触发gc，另外在2分钟未gc的时候也会触发gc.

为对象分配内存的时候是使用mallocgc这个方法，具体可以看[golang内存分配](http://www.cnblogs.com/yjf512/p/5147365.html)。

这个分配是将对象分为大对象，小对象，和微小对象三种类型进行分配的。再分配完成内存后，先会把当前这个对象标记为黑色。

```
func mallocgc(size uintptr, typ *_type, flags uint32) unsafe.Pointer {

    ...

    // 直接把分配的对象标记为黑色
	if gcphase == _GCmarktermination || gcBlackenPromptly {
		systemstack(func() {
			gcmarknewobject_m(uintptr(x), size)
		})
	}

    ...

    // 检查是否应该触发gc
	if shouldhelpgc && shouldtriggergc() {
		startGC(gcBackgroundMode, false)
	}

    ...

	return x
}
```

那么这里的shouldtriggergc()就是判断是否要进行gc的了，可以看出触发的条件是：
1 如果已经有gc在工作了，就不进行触发
2 当heap_live大于next_gc的时候触发

```
func shouldtriggergc() bool {
	return memstats.heap_live >= memstats.next_gc && atomicloaduint(&bggc.working) == 0
}
```

这里heap_live表示从上次回收以后堆使用的内存。而next_gc是下次垃圾回收的阀值。

next_gc在初始化的时候会进行定义，初始化为4MB。
